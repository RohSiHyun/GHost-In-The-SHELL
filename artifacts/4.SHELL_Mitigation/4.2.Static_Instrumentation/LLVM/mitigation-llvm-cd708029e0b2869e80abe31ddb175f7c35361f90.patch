diff --git a/clang/lib/CMakeLists.txt b/clang/lib/CMakeLists.txt
index 14ba55360fe0..bf730b738c98 100644
--- a/clang/lib/CMakeLists.txt
+++ b/clang/lib/CMakeLists.txt
@@ -35,3 +35,5 @@ add_subdirectory(Support)
 if(CLANG_ENABLE_CIR)
   add_subdirectory(CIR)
 endif()
+
+add_subdirectory(Custom)
\ No newline at end of file
diff --git a/clang/lib/Custom/CMakeLists.txt b/clang/lib/Custom/CMakeLists.txt
new file mode 100644
index 000000000000..d2802067e933
--- /dev/null
+++ b/clang/lib/Custom/CMakeLists.txt
@@ -0,0 +1,17 @@
+cmake_minimum_required(VERSION 3.13)
+
+project(PtrInstrumentPass LANGUAGES C CXX)
+
+# Find LLVM (user must define LLVM_DIR if not installed system-wide)
+find_package(LLVM REQUIRED CONFIG HINTS "${LLVM_CMAKE_DIR}")
+list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
+
+# Recommended: avoid RTTI mismatch
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD_REQUIRED YES)
+set(CMAKE_CXX_EXTENSIONS NO)
+
+# Plugin build
+add_llvm_pass_plugin(PtrInstrumentPass
+  InstrumentPass.cpp
+)
diff --git a/clang/lib/Custom/InstrumentPass.cpp b/clang/lib/Custom/InstrumentPass.cpp
new file mode 100644
index 000000000000..c7037ff9cb31
--- /dev/null
+++ b/clang/lib/Custom/InstrumentPass.cpp
@@ -0,0 +1,252 @@
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Passes/PassPlugin.h"
+#include "llvm/Passes/PassBuilder.h" 
+#include <unordered_set>
+
+using namespace llvm;
+
+namespace {
+struct PointerOriginPass : public PassInfoMixin<PointerOriginPass> {
+
+    void instrumentAlloca(AllocaInst *AI) {
+      Function *F = AI->getFunction();
+      LLVMContext &C = AI->getContext();
+      IRBuilder<> Builder(AI);
+
+      Type *ETy = AI->getAllocatedType();
+      DataLayout DL(AI->getModule());
+      uint64_t ElemSize = DL.getTypeAllocSize(ETy);
+      Value *ElemSizeVal = ConstantInt::get(Builder.getInt64Ty(), ElemSize);
+      Value *TotalSize = ElemSizeVal; 
+      
+      if( AI->isArrayAllocation()) {
+        TotalSize = Builder.CreateMul(AI->getArraySize(), ElemSizeVal, "total_size");
+      }
+      
+      Module *M = AI->getModule();
+      FunctionCallee InstMallocFunc = M->getOrInsertFunction(
+          "instru_malloc",
+          FunctionType::get(Type::getInt8Ty(C)->getPointerTo(0), {Builder.getInt64Ty()}, false));
+      
+      Value *MallocCall = Builder.CreateCall(InstMallocFunc, TotalSize, "malloc_instrumented");
+      Value *TypedMalloc = Builder.CreateBitCast(MallocCall, AI->getType(), "casted_alloca");
+
+      AI->replaceAllUsesWith(TypedMalloc);
+      
+      FunctionCallee InstFreeFunc = M->getOrInsertFunction(
+          "instru_free",
+          FunctionType::get(Type::getVoidTy(C), {Type::getInt8Ty(C)->getPointerTo(0)}, false));
+      
+      for (auto &BB : *F) {
+        if (isa<ReturnInst>(BB.getTerminator())) {
+          IRBuilder<> RetBuilder(BB.getTerminator());
+          Value *ToFree = RetBuilder.CreateBitCast(TypedMalloc, Type::getInt8Ty(C)->getPointerTo(0), "casted_free");
+          RetBuilder.CreateCall(InstFreeFunc, {ToFree});
+          return;
+        }
+      }
+    }
+
+    void instrumentMalloc(CallBase *CB) {
+      Module *M = CB->getModule();
+      LLVMContext &C = M->getContext();
+      IRBuilder<> Builder(CB);
+      FunctionCallee InstMallocFunc = M->getOrInsertFunction(
+          "instru_malloc",
+          FunctionType::get(Type::getInt8Ty(C)->getPointerTo(0), {Builder.getInt64Ty()}, false));
+ 
+      Value *Arg = CB->getArgOperand(0);
+      CallInst *NewCall = Builder.CreateCall(InstMallocFunc, Arg, "malloc_instrumented");
+      CB->replaceAllUsesWith(NewCall);
+      CB->eraseFromParent();
+
+    }
+
+    void instrumentMmap(CallBase *CB) {
+      Module *M = CB->getModule();
+      LLVMContext &C = M->getContext();
+      IRBuilder<> Builder(CB);
+
+      FunctionCallee InstMmapFunc = M->getOrInsertFunction(
+          "mmap",
+          FunctionType::get(Type::getInt8Ty(M->getContext())->getPointerTo(0), {Type::getInt8Ty(M->getContext())->getPointerTo(0), 
+            Type::getInt64Ty(M->getContext()), Type::getInt32Ty(M->getContext()), Type::getInt64Ty(M->getContext()),
+            Type::getInt32Ty(M->getContext()), Type::getInt64Ty(M->getContext())}, false));
+
+      SmallVector<Value *, 6> NewArgs;
+      for (unsigned i = 0; i < 6; ++i)
+        NewArgs.push_back(CB->getArgOperand(i));
+
+      Value *FlagMask = ConstantInt::get(Type::getInt64Ty(C), 0x1000000000000000ULL);
+      Value *ModifiedFlags = Builder.CreateOr(NewArgs[3], FlagMask, "flags_or");
+
+      NewArgs[3] = ModifiedFlags;
+      CallInst *NewCall = Builder.CreateCall(InstMmapFunc, NewArgs, "mmap_instrumented");
+      CB->replaceAllUsesWith(NewCall);
+      CB->eraseFromParent();
+    }
+
+    Value* findPointerOrigin(Value *V, std::unordered_set<Value*> &Visited) {
+        if (!V || Visited.count(V)) return nullptr;
+        Visited.insert(V);
+
+        if (auto *AI = dyn_cast<AllocaInst>(V)) {
+            if (AI->getAllocatedType()->isPointerTy()) {
+                for (User *U : AI->users()) {
+                    if (auto *SI = dyn_cast<StoreInst>(U)) {
+                        Value *stored = SI->getValueOperand();
+                        return findPointerOrigin(stored, Visited);
+                    }
+                }
+                return nullptr;
+            }
+            instrumentAlloca(AI);
+            errs() << "  -> stack (alloca): " << *AI << "\n";
+            return V;
+        }
+
+        if (auto *GV = dyn_cast<GlobalVariable>(V)) {
+            errs() << "  -> global: " << GV->getName() << "\n";
+            return V;
+        }
+        if (auto *CB = dyn_cast<CallBase>(V)) {
+            Value *CalledVal = CB->getCalledOperand();
+
+            if (Function *F = dyn_cast<Function>(CalledVal)) {
+                StringRef Name = F->getName();
+                if (Name == "malloc") {
+                    errs() << "  -> heap (" << Name << "): " << *CB << "\n";
+                    instrumentMalloc(CB);
+                    return V;
+                } else if (Name == "mmap") {
+                    instrumentMmap(CB);
+                    return V;
+                }
+            } else if (CalledVal) {
+                if (auto *CE = dyn_cast<ConstantExpr>(CalledVal)) {
+                    if (CE->isCast()) {
+                        if (Function *F = dyn_cast<Function>(CE->getOperand(0))) {
+                            StringRef Name = F->getName();
+                            if (Name == "malloc") {
+                                errs() << "  -> heap (indirect " << Name << "): " << *CB << "\n";
+                                instrumentMalloc(CB);
+                                return V;
+                            } else if (Name == "mmap") {
+                               instrumentMmap(CB);
+                               return V;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if (auto *BC = dyn_cast<BitCastInst>(V))
+            return findPointerOrigin(BC->getOperand(0), Visited);
+
+        if (auto *GEP = dyn_cast<GetElementPtrInst>(V))
+            return findPointerOrigin(GEP->getPointerOperand(), Visited);
+
+        if (auto *LI = dyn_cast<LoadInst>(V))
+            return findPointerOrigin(LI->getPointerOperand(), Visited);
+
+        if (auto *Arg = dyn_cast<Argument>(V)) {
+            Function *Parent = Arg->getParent();
+            for (User *U : Parent->users()) {
+                if (auto *Call = dyn_cast<CallBase>(U)) {
+                    if (Arg->getArgNo() < Call->arg_size()) {
+                        Value *PassedVal = Call->getArgOperand(Arg->getArgNo());
+                        errs() << "  -> passed from caller: " << Call->getCaller()->getName() << "\n";
+                        return findPointerOrigin(PassedVal, Visited);
+                    }
+                }
+            }
+        }
+
+        return nullptr;
+    }
+
+    PreservedAnalyses run(Module &M, ModuleAnalysisManager &) {
+
+        LLVMContext &Ctx = M.getContext();
+
+        if(!M.getFunction("instru_malloc")) {
+            FunctionType *MallocType = FunctionType::get(
+                Type::getInt8Ty(Ctx)->getPointerTo(0),
+                {Type::getInt64Ty(Ctx)},
+                false
+            );
+            FunctionType *FreeType = FunctionType::get(
+                Type::getVoidTy(Ctx),
+                {Type::getInt8Ty(Ctx)->getPointerTo(0)},
+                false
+            );
+            Function::Create(MallocType, Function::ExternalLinkage, "instru_malloc", M);
+            Function::Create(FreeType, Function::ExternalLinkage, "instru_free", M);
+        }
+
+        FunctionCallee instruFree = M.getOrInsertFunction(
+            "instru_free",
+            FunctionType::get(Type::getVoidTy(Ctx), {Type::getInt8Ty(Ctx)->getPointerTo(0)}, false)
+        );
+       
+        for (Function &F : M) {
+            for (BasicBlock &BB : F) {
+                for (auto It = BB.begin(); It != BB.end(); ) {
+                    Instruction *I = &*It++;
+                    if (auto *CB = dyn_cast<CallBase>(I)) {
+                        Value *Callee = CB->getCalledOperand()->stripPointerCasts();
+                        Function *F = dyn_cast<Function>(Callee);
+                        if (!F || F->getName() != "free") continue;
+
+                        if (CB->arg_size() != 1) continue; // sanity check
+
+                        IRBuilder<> Builder(CB);
+                        Value *Arg = CB->getArgOperand(0);
+                        Builder.CreateCall(instruFree, {Arg});
+
+                        CB->eraseFromParent();  // Remove the original call
+                    }
+                }
+            }
+        }
+
+        for (Function &F : M) {
+            if (F.isDeclaration()) continue;
+            if (!F.getName().starts_with("target")) continue;
+            errs() << "Function: " << F.getName() << "\n";
+            for (Argument &Arg : F.args()) {
+                if (!Arg.getType()->isPointerTy()) continue;
+
+                errs() << "  Pointer argument: " << Arg.getName() << "\n";
+                std::unordered_set<Value*> visited;
+                findPointerOrigin(&Arg, visited);
+            }
+        }
+        return PreservedAnalyses::all();
+    }
+};
+} // namespace
+
+/// Plugin registration
+extern "C" ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() {
+    return {
+        LLVM_PLUGIN_API_VERSION, "PointerOriginPass", LLVM_VERSION_STRING,
+        [](PassBuilder &PB) {
+            PB.registerPipelineParsingCallback(
+                [](StringRef Name, ModulePassManager &MPM,
+                   ArrayRef<PassBuilder::PipelineElement>) {
+                    if (Name == "pointer-origin-pass") {
+                        MPM.addPass(PointerOriginPass());
+                        return true;
+                    }
+                    return false;
+                });
+        }
+    };
+}
